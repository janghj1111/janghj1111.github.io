---
comments: false
---



## Git 필수 명령어



### 기본 명령어
- `git init`: 새로운 Git 저장소 생성
- `git clone <url>`: 원격 저장소 복제
- `git add <파일명>`: 변경사항을 스테이징 영역에 추가
- `git commit -m "메시지"`: 스테이징된 변경사항을 커밋

### 브랜치 관련
- `git branch`: 브랜치 목록 확인
- `git branch <브랜치명>`: 새 브랜치 생성
- `git checkout <브랜치명>`: 브랜치 전환
- `git merge <브랜치명>`: 현재 브랜치에 다른 브랜치를 병합

### 원격 저장소
- `git remote add origin <url>`: 원격 저장소 추가
- `git push origin <브랜치명>`: 원격 저장소에 푸시
- `git pull origin <브랜치명>`: 원격 저장소에서 풀
- `git fetch`: 원격 저장소의 정보 가져오기

### 상태 확인
- `git status`: 현재 저장소 상태 확인
- `git log`: 커밋 히스토리 확인
- `git diff`: 변경사항 확인



## A 브랜치를 B 브랜치에 덮어쓰기

dev 브랜치를 main 브랜치에 덮어쓰고 싶을 떄


### ✅ **Git에서 `dev` 브랜치의 내용을 `main` 브랜치에 덮어쓰는 방법**

**현재 `dev` 브랜치의 코드로 `main` 브랜치를 완전히 덮어쓰려면**, `main` 브랜치에서 `dev`의 변경 사항을 강제로 적용해야 합니다.

---

### **📌 1️⃣ `main` 브랜치로 이동**

```
git checkout main

```

또는 최신 Git에서는 `switch` 사용 가능

```
git switch main

```

---

### **📌 2️⃣ `dev` 브랜치의 최신 상태 가져오기**

먼저 `dev` 브랜치가 최신 상태인지 확인 후, 최신 커밋을 `pull` 합니다.

```
git checkout dev
git pull origin dev

```

---

### **📌 3️⃣ `main` 브랜치에 `dev`의 내용 강제 덮어쓰기**

```
git reset --hard dev

```

이 명령어는 **현재 `main` 브랜치의 모든 내용을 `dev` 브랜치와 동일하게 강제 변경**합니다.

---

### **📌 4️⃣ `main` 브랜치를 원격 저장소에 강제로 업데이트**

```
git push origin main --force

```

- `-force`를 사용하면 원격 `main` 브랜치의 기록을 `dev`와 동일하게 덮어씁니다.
- 기존 `main` 브랜치의 기록이 사라지므로, **이전 기록이 필요하다면 백업(`git branch backup-main`)을 먼저 생성하는 것이 안전합니다.**

---

### **📌 (선택) 기존 `main` 브랜치 백업**

혹시 모를 실수를 대비하여 기존 `main` 브랜치를 백업하는 것이 좋습니다.

```
git branch backup-main main

```

이제 `backup-main` 브랜치에 기존 `main` 상태가 저장되므로, 만약 실수하면 되돌릴 수 있습니다.

---

### **🚀 최종 정리**

1. `main` 브랜치로 이동 → `git checkout main`
2. `dev`의 최신 상태 확인 → `git checkout dev && git pull origin dev`
3. `main`을 `dev`로 덮어쓰기 → `git reset --hard dev`
4. 원격 `main`에 강제 푸시 → `git push origin main --force`
5. (선택) 기존 `main` 백업 → `git branch backup-main main`

✅ 이제 `dev` 브랜치의 코드가 완전히 `main` 브랜치에 덮어씌워집니다! 🚀



## dev 브랜치를 main 브랜치에 적용하기

### ✅ **`dev` 브랜치에서 개발한 내용을 `main` 브랜치에 적용하는 방법**
보통 **개발(`dev`) 브랜치에서 작업한 내용을 `main` 브랜치에 반영하려면** 두 가지 방법을 사용합니다.

1. **`merge`** → `dev`의 변경 사항을 `main`에 합치기 (기본 방식)  
2. **`rebase`** → `main` 브랜치의 최신 변경 사항을 `dev`에 적용 후, `main`에 반영 (히스토리 정리)

---

## **🔥 1. `merge` 방식 (가장 일반적인 방법)**
> **`dev`에서 개발 후, `main` 브랜치로 병합하는 기본적인 방법**

### **📌 `dev`를 `main`에 병합하는 방법**
```sh
# 1️⃣ main 브랜치로 이동
git checkout main  # 또는 git switch main

# 2️⃣ 최신 상태로 업데이트
git pull origin main

# 3️⃣ dev 브랜치를 main에 병합 (merge)
git merge dev

# 4️⃣ 병합된 내용 푸시
git push origin main
```

### **✅ `merge` 방식의 특징**
- 기존 `dev` 브랜치의 **모든 커밋이 유지됨** (히스토리가 남음)
- `main` 브랜치에 새로운 **병합(commit) 기록**이 생성됨
- **`main`과 `dev`의 커밋 로그가 유지되므로 추적이 쉬움**

---

## **🔥 2. `rebase` 방식 (히스토리를 깔끔하게 유지)**
> `rebase`는 `dev`의 커밋을 `main` 브랜치의 최신 커밋 위로 정리하는 방식

### **📌 `dev`를 `main` 위로 재정렬하는 방법**
```sh
# 1️⃣ main 브랜치로 이동
git checkout main  # 또는 git switch main

# 2️⃣ 최신 상태로 업데이트
git pull origin main

# 3️⃣ dev 브랜치로 이동
git checkout dev  # 또는 git switch dev

# 4️⃣ main 브랜치의 변경 사항을 dev에 적용 (rebase)
git rebase main

# 5️⃣ dev 브랜치를 다시 main에 병합 (Fast-forward 방식)
git checkout main
git merge dev

# 6️⃣ 깔끔한 히스토리로 push
git push origin main
```

### **✅ `rebase` 방식의 특징**
- `main` 브랜치가 항상 **깨끗한 선형 히스토리**를 유지함
- `merge` 방식보다 **히스토리가 간결**해짐
- **주의:** `dev` 브랜치에 이미 Push한 커밋을 `rebase` 하면 충돌이 발생할 가능성이 있음

---

## **🚀 3. `Pull Request (PR)` 또는 `Merge Request (MR)` 방식 (협업 시 추천)**
> **팀 협업 시 가장 많이 사용하는 방법**  
GitHub, GitLab, Bitbucket 등의 플랫폼을 사용하면 `dev`에서 `main`으로 병합하는 **Pull Request (PR)** 또는 **Merge Request (MR)** 를 활용할 수 있습니다.

### **📌 PR/MR 진행 순서**
1. **`dev` 브랜치에서 작업을 완료하고 Push**
```sh
git checkout dev
git add .
git commit -m "feat: 새로운 기능 추가"
git push origin dev
```
2. GitHub/GitLab에서 `dev` → `main` 브랜치로 **Pull Request (PR) 생성**
3. 팀원 리뷰 후 **"Merge" 버튼 클릭**
4. `dev` 브랜치가 `main`에 반영됨

### **✅ PR/MR 방식의 특징**
- **코드 리뷰가 가능**하여 안정적인 배포가 가능
- 협업에 적합하고, GitHub/GitLab에서 자동 테스트 및 코드 품질 검사를 수행 가능
- `dev` 브랜치에서 계속 새로운 기능 개발이 가능

---

## **🚀 최종 정리 (어떤 방법을 선택해야 할까?)**
| 방법 | 특징 | 추천 상황 |
|------|------|------|
| **`merge`** | 기존 커밋 기록 유지, 충돌 발생 가능 | 가장 일반적인 방식, 협업 가능 |
| **`rebase`** | 히스토리 깔끔함, 충돌 가능성 있음 | 개인 프로젝트, 깔끔한 커밋 로그 유지 필요 시 |
| **PR/MR** | 코드 리뷰 가능, 협업 최적화 | 팀 협업 시 필수 |

**💡 결론:**  
✅ **개인 프로젝트** → `rebase` 사용하여 히스토리 정리 후 병합  
✅ **팀 협업** → `Pull Request (PR)` 또는 `Merge Request (MR)` 활용  
✅ **빠르게 병합이 필요하면** → `merge` 사용

🚀 **대부분의 협업 프로젝트에서는 "PR/MR → merge" 방식이 가장 많이 사용됩니다!**



**추가 이슈**

git merge dev를 하려니까 아래같은 에러 발생
fatal: refusing to merge unrelated histories

이럴때는 아래 명령어 실행


이 에러는 두 Git 저장소의 히스토리가 서로 관련이 없을 때 발생합니다. 주로 다음과 같은 상황에서 발생합니다:
- 새로운 저장소를 생성하고 원격 저장소와 연결할 때
- 두 개의 다른 프로젝트를 병합하려고 할 때

해결하기 위해서는 `--allow-unrelated-histories` 옵션을 사용하면 됩니다:

```bash
git merge dev --allow-unrelated-histories
```

하지만 주의하실 점:
1. 이 명령어를 실행하기 전에 현재 작업 내용을 백업해두시는 것이 좋습니다
2. 병합 후에 충돌이 발생할 수 있으므로, 충돌 해결 준비를 하시는 것이 좋습니다
3. 이는 일반적인 상황에서는 권장되지 않는 방법이므로, 정말 필요한 경우에만 사용하시기 바랍니다

만약 이것이 새로운 프로젝트라면, 아래와 같은 대안도 고려해보세요:
1. 저장소를 새로 클론하기
2. 원격 저장소를 다시 설정하기
3. git pull을 먼저 실행한 후 작업 시작하기



## A브랜치에서 작업한 일부 소스들만 B브랜치에 푸쉬하고 싶으면 어떻게 하고 충돌 날 땐 어떻게 해?

git CLI 버전 

### ✅ **A 브랜치에서 작업한 일부 소스만 B 브랜치에 푸시하는 방법**
A 브랜치에서 특정 파일 또는 특정 커밋만 B 브랜치로 적용하고 싶다면 여러 방법이 있습니다.

---

## **🔥 1. 특정 파일만 B 브랜치에 반영하는 방법**
### **📌 `git checkout` 또는 `git restore` 활용**
A 브랜치에서 특정 파일만 선택하여 B 브랜치로 반영할 수 있습니다.

```sh
# 1️⃣ B 브랜치로 이동
git checkout B  # 또는 git switch B

# 2️⃣ A 브랜치에서 원하는 파일을 가져옴
git checkout A -- 파일이름

# 3️⃣ 변경 사항 커밋
git add 파일이름
git commit -m "A 브랜치에서 파일 일부만 반영"

# 4️⃣ B 브랜치에 푸시
git push origin B
```

### **✅ 이 방식의 특징**
- **파일 단위로 선택 가능** (`git checkout A -- 파일이름`)
- **A 브랜치의 변경 사항을 B 브랜치에 적용 가능**
- **충돌이 발생할 경우, 변경 사항을 직접 수정 후 커밋하면 해결 가능**

---

## **🔥 2. 특정 커밋만 B 브랜치에 적용하는 방법**
### **📌 `cherry-pick` 활용**
A 브랜치에서 특정 커밋만 선택하여 B 브랜치에 반영할 수도 있습니다.

```sh
# 1️⃣ B 브랜치로 이동
git checkout B  # 또는 git switch B

# 2️⃣ A 브랜치의 특정 커밋 가져오기 (커밋 해시 확인)
git log A --oneline  # 커밋 해시를 확인

# 3️⃣ 특정 커밋을 B 브랜치에 적용
git cherry-pick <커밋해시>

# 4️⃣ 충돌 발생 시 해결 후 커밋
git add .
git cherry-pick --continue  # 충돌 해결 후 진행

# 5️⃣ B 브랜치에 푸시
git push origin B
```

### **✅ `cherry-pick` 방식의 특징**
- **특정 커밋만 선택해서 가져올 수 있음**
- **충돌이 발생하면 수동으로 수정 후 진행 가능**
- **A 브랜치의 전체 변경 사항이 아니라 필요한 커밋만 반영 가능**

---

## **🔥 3. 충돌이 발생하면 어떻게 해결할까?**
### **📌 충돌 해결하는 방법**
만약 **파일을 B 브랜치에 적용하는 과정에서 충돌이 발생하면**, 다음 순서로 해결하면 됩니다.

```sh
# 1️⃣ 충돌이 발생한 파일 확인
git status

# 2️⃣ 충돌 해결 후 변경 사항 스테이징
git add .

# 3️⃣ cherry-pick을 계속 진행 (cherry-pick 사용 시)
git cherry-pick --continue

# 4️⃣ 커밋 후 B 브랜치에 푸시
git push origin B
```

### **✅ 충돌 해결 방법**
- **충돌이 발생한 파일을 열어 직접 수정**
- **사용할 코드만 남기고 `git add .` 후 진행**
- **기존 커밋을 유지하고 싶다면 `git cherry-pick --skip` 사용 가능**

---

## **🚀 최종 정리 (어떤 방법을 선택해야 할까?)**
| 방법 | 특징 | 추천 상황 |
|------|------|------|
| **특정 파일만 반영 (`git checkout A -- 파일`)** | 파일 단위로 반영 가능 | 일부 파일만 옮길 때 |
| **특정 커밋만 반영 (`git cherry-pick`)** | 커밋 단위로 반영 가능 | 필요한 변경 사항만 적용할 때 |
| **충돌 해결 (`git status` 후 수동 해결)** | 직접 수정 가능 | A와 B 브랜치에 같은 파일이 수정된 경우 |

**💡 추천 방법:**  
✅ **파일 단위로 옮기려면 `git checkout A -- 파일이름`**  
✅ **커밋 단위로 옮기려면 `git cherry-pick <커밋해시>`**  
✅ **충돌이 발생하면 `git status`로 확인 후 수동 해결**  

🚀 **이제 필요한 코드만 안전하게 B 브랜치에 반영할 수 있습니다!** 🎉

### ✅ **A 브랜치에서 작업한 일부 소스만 B 브랜치에 푸시하는 방법**
A 브랜치에서 특정 파일 또는 특정 커밋만 B 브랜치로 적용하고 싶다면 여러 방법이 있습니다.

---

## **🔥 1. 특정 파일만 B 브랜치에 반영하는 방법**
### **📌 `git checkout` 또는 `git restore` 활용**
A 브랜치에서 특정 파일만 선택하여 B 브랜치로 반영할 수 있습니다.

```sh
# 1️⃣ B 브랜치로 이동
git checkout B  # 또는 git switch B

# 2️⃣ A 브랜치에서 원하는 파일을 가져옴
git checkout A -- 파일이름

# 3️⃣ 변경 사항 커밋
git add 파일이름
git commit -m "A 브랜치에서 파일 일부만 반영"

# 4️⃣ B 브랜치에 푸시
git push origin B
```

### **✅ 이 방식의 특징**
- **파일 단위로 선택 가능** (`git checkout A -- 파일이름`)
- **A 브랜치의 변경 사항을 B 브랜치에 적용 가능**
- **충돌이 발생할 경우, 변경 사항을 직접 수정 후 커밋하면 해결 가능**

---

## **🔥 2. 특정 커밋만 B 브랜치에 적용하는 방법**
### **📌 `cherry-pick` 활용**
A 브랜치에서 특정 커밋만 선택하여 B 브랜치에 반영할 수도 있습니다.

```sh
# 1️⃣ B 브랜치로 이동
git checkout B  # 또는 git switch B

# 2️⃣ A 브랜치의 특정 커밋 가져오기 (커밋 해시 확인)
git log A --oneline  # 커밋 해시를 확인

# 3️⃣ 특정 커밋을 B 브랜치에 적용
git cherry-pick <커밋해시>

# 4️⃣ 충돌 발생 시 해결 후 커밋
git add .
git cherry-pick --continue  # 충돌 해결 후 진행

# 5️⃣ B 브랜치에 푸시
git push origin B
```

### **✅ `cherry-pick` 방식의 특징**
- **특정 커밋만 선택해서 가져올 수 있음**
- **충돌이 발생하면 수동으로 수정 후 진행 가능**
- **A 브랜치의 전체 변경 사항이 아니라 필요한 커밋만 반영 가능**

---

## **🔥 3. 충돌이 발생하면 어떻게 해결할까?**
### **📌 충돌 해결하는 방법**
만약 **파일을 B 브랜치에 적용하는 과정에서 충돌이 발생하면**, 다음 순서로 해결하면 됩니다.

```sh
# 1️⃣ 충돌이 발생한 파일 확인
git status

# 2️⃣ 충돌 해결 후 변경 사항 스테이징
git add .

# 3️⃣ cherry-pick을 계속 진행 (cherry-pick 사용 시)
git cherry-pick --continue

# 4️⃣ 커밋 후 B 브랜치에 푸시
git push origin B
```

### **✅ 충돌 해결 방법**
- **충돌이 발생한 파일을 열어 직접 수정**
- **사용할 코드만 남기고 `git add .` 후 진행**
- **기존 커밋을 유지하고 싶다면 `git cherry-pick --skip` 사용 가능**

---

## **🚀 최종 정리 (어떤 방법을 선택해야 할까?)**
| 방법 | 특징 | 추천 상황 |
|------|------|------|
| **특정 파일만 반영 (`git checkout A -- 파일`)** | 파일 단위로 반영 가능 | 일부 파일만 옮길 때 |
| **특정 커밋만 반영 (`git cherry-pick`)** | 커밋 단위로 반영 가능 | 필요한 변경 사항만 적용할 때 |
| **충돌 해결 (`git status` 후 수동 해결)** | 직접 수정 가능 | A와 B 브랜치에 같은 파일이 수정된 경우 |

**💡 추천 방법:**  
✅ **파일 단위로 옮기려면 `git checkout A -- 파일이름`**  
✅ **커밋 단위로 옮기려면 `git cherry-pick <커밋해시>`**  
✅ **충돌이 발생하면 `git status`로 확인 후 수동 해결**  

🚀 **이제 필요한 코드만 안전하게 B 브랜치에 반영할 수 있습니다!** 🎉

소스트리 버전 

### ✅ **소스트리(Sourcetree)에서 A 브랜치의 일부 파일 또는 특정 커밋만 B 브랜치에 반영하는 방법**  
소스트리에서 A 브랜치의 변경 사항 중 일부만 B 브랜치에 적용하려면 **파일 단위** 또는 **커밋 단위** 방법을 사용할 수 있습니다.

---


## **🔥 1. 특정 파일만 B 브랜치에 반영하는 방법**
### **📌 `A` 브랜치에서 특정 파일만 `B` 브랜치로 반영하는 방법**
1. **소스트리에서 `B` 브랜치로 체크아웃**
   - `B` 브랜치를 선택한 후 **"체크아웃"** 클릭

2. **"작업 트리" 탭에서 "다른 브랜치에서 파일 가져오기" 선택**
   - 상단 메뉴에서 **"작업 트리"** → **"작업"** 클릭  
   - "다른 브랜치에서 파일 가져오기" 선택

3. **A 브랜치에서 특정 파일 선택**
   - "가져올 브랜치"에서 `A` 브랜치를 선택  
   - "가져올 파일"에서 특정 파일만 체크한 후 "확인" 클릭

4. **스테이징 후 커밋 & 푸시**
   - 파일이 `B` 브랜치에 반영되었으면 **커밋 후 푸시**하면 완료 🎉

### ✅ **이 방법의 특징**
- 특정 파일만 선택 가능
- 불필요한 코드 변경 없이 필요한 것만 반영
- 충돌이 발생하면 직접 수정 가능

---

## **🔥 2. 특정 커밋만 B 브랜치에 반영하는 방법 (`cherry-pick`)**
### **📌 `cherry-pick`을 사용해 특정 커밋만 가져오기**
1. **소스트리에서 `B` 브랜치로 체크아웃**
   - `B` 브랜치를 선택하고 **"체크아웃"** 클릭

2. **A 브랜치에서 가져올 커밋을 선택**
   - **A 브랜치의 커밋 목록에서 필요한 커밋을 우클릭**
   - **"커밋 가져오기(Cherry Pick)"** 선택

3. **충돌 발생 시 해결**
   - 충돌이 발생하면 **"수정 후 해결"**을 클릭하여 충돌 파일을 직접 수정  
   - 수정 완료 후 **"변경 사항 스테이징"** 버튼 클릭 → **커밋 진행**

4. **푸시 완료**
   - B 브랜치에서 커밋이 정상적으로 추가되었으면 `origin B`로 푸시 🎉

### ✅ **이 방법의 특징**
- 특정 커밋만 `B` 브랜치에 반영 가능
- `A` 브랜치에서 여러 개의 커밋을 가져오려면 반복 실행
- 충돌이 발생하면 직접 수정 가능

---

## **🔥 3. 충돌이 발생하면 어떻게 해결할까?**
### **📌 소스트리에서 충돌 해결하는 방법**
1. 충돌이 발생하면 **"수정 후 해결"** 버튼 클릭  
2. **충돌이 발생한 파일을 직접 수정**
   - 파일을 열고 **사용할 코드만 남기고 저장**
3. **소스트리에서 "변경 사항 스테이징" 후 "커밋" 진행**
4. **푸시하여 최종 적용**

---

## **🚀 최종 정리 (어떤 방법을 선택해야 할까?)**
| 방법 | 특징 | 추천 상황 |
|------|------|------|
| **특정 파일만 반영 (다른 브랜치에서 파일 가져오기)** | 파일 단위로 반영 가능 | 일부 파일만 이동할 때 |
| **특정 커밋만 반영 (`cherry-pick`)** | 특정 커밋만 선택해서 반영 가능 | 필요한 기능만 가져올 때 |
| **충돌 해결 (수정 후 해결)** | 직접 수정 가능 | A와 B 브랜치에서 같은 파일을 수정한 경우 |

✅ **파일 단위 이동** → `"다른 브랜치에서 파일 가져오기"`  
✅ **커밋 단위 이동** → `"cherry-pick"`  
✅ **충돌 발생 시** → `"수정 후 해결"`로 직접 수정  

🚀 **이제 소스트리에서 원하는 코드만 안전하게 B 브랜치에 반영할 수 있습니다!** 🎉